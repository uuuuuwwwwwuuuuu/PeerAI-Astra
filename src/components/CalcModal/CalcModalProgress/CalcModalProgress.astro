---
import './calcModalProgress.scss';

interface Props {
    title: string,
    unitType: "MAUs" | 'builds' | 'mins';
}

const {title, unitType} = Astro.props

---

<div class="progress_wrapper">
    <div class="progress_info_line">
        <span class="progress_title">{title}</span>
        <span class="progress_value">

        </span>
    </div>
    <div class="bg_progress_bar">
        <div class="progress_bar" >
            <div class="progress_bar_circle" data-unit-type={unitType}></div>
        </div>
    </div>
</div>

<script>
const progressCircleList: NodeListOf<HTMLDivElement> = document.querySelectorAll('.progress_bar_circle');
const progressBarBg: HTMLDivElement | null = document.querySelector('.bg_progress_bar');
const progressTitle: HTMLSpanElement | null = document.querySelector('.progress_title');
const progressValueSpanList = document.querySelectorAll('.progress_value');
const progressBarList: NodeListOf<HTMLDivElement> = document.querySelectorAll('.progress_bar');

type unitTypes =  "MAUs" | "builds" | 'mins'

const convertWidthToPercents = (currentWidth: number, wrapperWidth: number) => {
    return +((currentWidth * 100) / wrapperWidth).toFixed(4);
};

const convertPercentsToValue = (unit: unitTypes, currentPercents: number) => {
    let maxValue: number;
    
    if (unit === 'MAUs') {
        maxValue = 1000000;
    } else if (unit === 'builds') {
        maxValue = 1000;
    } else {
        maxValue = 3000;
    }
    
    const t = currentPercents / 100;
    const exponentialProgress = Math.pow(t, 3);
    
    const value = Math.floor(exponentialProgress * maxValue);

    return value;
};

let isMouseDown = false;


function convertProgressValue (progressValue: number) {
    if (window.innerWidth <= 400) {
        if (progressValue >= 1000000) {
            return progressValue.toString()[0] + 'M'
        } else if (progressValue >= 100000) {
            return progressValue.toString().substring(0, 3) + 'K'
        } else if (progressValue >= 10000) {
            return progressValue.toString().substring(0, 2) + 'K'
        } else if (progressValue >= 1000) {
            return progressValue.toString()[0] + 'K'
        }
        return progressValue;
    }
    return progressValue;
}

const setProgressValue = (unitType: unitTypes, progressValue: number) => {
    switch (unitType) {
        case 'MAUs':
            progressValueSpanList[0].textContent = `${convertProgressValue(progressValue)} ${unitType}`;
            break
        case 'builds':
            progressValueSpanList[1].textContent = `${convertProgressValue(progressValue)} ${unitType}`;
            break
        case 'mins':
            progressValueSpanList[2].textContent = `${convertProgressValue(progressValue)} ${unitType}`;
            break
    }
}

const setProgressWidth = (unitType: unitTypes, progressWidth: number) => {
    switch (unitType) {
        case 'MAUs':
            progressBarList[0].style.width = progressWidth + '%';
            break
        case 'builds':
            progressBarList[1].style.width = progressWidth + '%';
            break
        case 'mins':
            progressBarList[2].style.width = progressWidth + '%';
            break
    }
}

const handleMouseMove = (event: MouseEvent) => {
    if (isMouseDown && progressBarBg) {
        const progressRect = progressBarBg.getBoundingClientRect();
        const mouseX = event.clientX - progressRect.left;

        const currentCircle = event.target as HTMLDivElement;
        const unitType: unitTypes = currentCircle.getAttribute('data-unit-type') as unitTypes

        const newProgress = convertWidthToPercents(mouseX, progressRect.width);
        
        let progressValue = 0;

        if (newProgress <= 0) {
            setProgressWidth(unitType, 0)
            progressValue = convertPercentsToValue(unitType, 0);
        } else if (newProgress >= 100) {
            setProgressWidth(unitType, 100)
            progressValue = convertPercentsToValue(unitType, 100);
        } else {
            setProgressWidth(unitType, newProgress)
            progressValue = convertPercentsToValue(unitType, newProgress);
        }

        setProgressValue(unitType, progressValue);
    }
}

const handleTouchMove = (event: TouchEvent) => {
    if (isMouseDown && progressBarBg) {
        const progressRect = progressBarBg.getBoundingClientRect();
        const touch = event.touches[0];
        const touchX = touch.clientX - progressRect.left;
        
        const currentCircle = event.target as HTMLDivElement;
        const unitType: unitTypes = currentCircle.getAttribute('data-unit-type') as unitTypes


        const newProgress = convertWidthToPercents(touchX, progressRect.width);
        let progressValue = 0;
        
        if (newProgress <= 0) {
            setProgressWidth(unitType, 0)
            progressValue = convertPercentsToValue(unitType, 0);
        } else if (newProgress >= 100) {
            setProgressWidth(unitType, 100)
            progressValue = convertPercentsToValue(unitType, 100);
        } else {
            setProgressWidth(unitType, newProgress)
            progressValue = convertPercentsToValue(unitType, newProgress);
        }

        setProgressValue(unitType, progressValue);
    }
}

progressCircleList.forEach(circle => {
    circle.addEventListener('mousedown', () => {isMouseDown = true});
    circle.addEventListener('mouseup', () => {isMouseDown = false});
    circle.addEventListener('mouseleave', () => {isMouseDown = false});

    circle.addEventListener('touchstart', () => {isMouseDown = true});
    circle.addEventListener('touchend', () => {isMouseDown = false});

    circle.addEventListener('mousemove', handleMouseMove);
    circle.addEventListener('touchmove', handleTouchMove);
});

setProgressValue('MAUs', 0);
setProgressValue('builds', 0);
setProgressValue('mins', 0);

setProgressWidth('MAUs', 0);
setProgressWidth('builds', 0);
setProgressWidth('mins', 0);

</script>